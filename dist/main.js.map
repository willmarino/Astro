{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/platform.js","webpack:///./src/environment.js","webpack:///./src/projectile.js","webpack:///./src/human.js","webpack:///./src/background.js","webpack:///./src/computer.js","webpack:///./src/score.js","webpack:///./src/land_computer.js","webpack:///./src/util/collision_logic.js","webpack:///./src/index.js","webpack:///./src/game.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Platform","xStart","yStart","width","height","this","context","fillStyle","fillRect","x","y","Environment","dimensions","human","platforms","generatePlatforms","push","length","prevPlat","newYStart","generatePlatformYStart","generatePlatformGap","generatePlatformWidth","randHeight","prevPlatHeight","randomOffset","Math","round","random","draw","action","move","that","xPos","xVel","forEach","plat","shift","pop","newPlatWidth","nextPlat","unshift","Projectile","player","projectileXVel","projectileYVel","homing","owner","type","didHit","playerXVel","playerXPos","playerYPos","yPos","yVel","alive","id","projectileCount","homingMove","homingDraw","computerProjectileMove","humanProjectileMove","Human","environment","computerProjectiles","CONSTANTS","GRAVITY","NORMALFORCE","projectiles","jumping","additionalScore","curJumps","dashes","onFloor","curPlat","lastPlat","movingLeft","movingRight","goingDown","distanceCovered","bindLeft","bindRight","bindUndoRight","bindUndoLeft","bindDown","bindUndoDown","bindDash","bindJump","setClick","applyGravity","getCurrentPlatform","isPlayerOnSide","window","addEventListener","e","moveLeft","moveRight","jump","down","setTimeout","canvas","rect","getBoundingClientRect","pos","clientX","left","clientY","top","newProj","configureProjectile","newId","assign","xDelta","yDelta","totalDeltasquared","pow","proportion","sqrt","obj1","obj2","obj1CenterX","obj1CenterY","obj1Diag","obj2CenterX","obj2CenterY","Background","colors","num","Computer","counterOffset","JETPACK","humanProjectiles","canShoot","initiateShot","setInterval","shoot","randNum","projectile","randOffset","squaredDeltaX","squaredDeltaY","totalDelta","switchDirection","collidedWithFloor","Score","initScore","score","font","fillText","LandComputer","posOffset","positions","getStartPlatforms","goingRight","goingLeft","right","mid","values","animate","filterProjectiles","collidedWithProjectiles","switchDirections","isOnEdge","beginJump","indexOf","heightDiff","abs","xGap","initYVel","endX","startX","xDiff","obj","calculateFall","dist","steps","maxHeight","calculateRise","roundedSteps","count","platform","hp","collide","objectCollision","game","getContext","running","computers","landComputers","computersBeingAdded","numComputers","projectileOffset","startMenu","document","getElementById","playButton","remove","click","grabHumanProjectiles","grabComputerProjectiles","checkCollisions","deleteProjectiles","offScreen","res","computer","CollisionUtil","filter","background","newCompStartX","comp","proj","compStartX","landComp","run","play","step","gameOver","rerun","switchRounds","filterComputers","requestAnimationFrame","animateProjectiles","setPlayerTracking","setNumComputers","spawnComputer","appendChild","restart"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","\n\nexport default class Platform{\n  constructor(xStart, yStart, width, height){\n    this.xStart = xStart;\n    this.yStart = yStart;\n    this.width = width;\n    this.height = height;\n  }\n\n  draw(context) {\n    context.fillStyle = 'black';\n    context.fillRect(this.xStart, this.yStart, this.width, this.height);\n  }\n\n  move(x, y){\n    this.xStart += x;\n    this.yStart += y;\n  }\n\n}"," import Platform from \"./platform\";\n\nexport default class Environment{\n  constructor(dimensions, context, human=null){\n    this.dimensions = {\n      height: dimensions.height,\n      width: dimensions.width\n    };\n    this.context = context;\n\n    this.height = 300;\n\n    this.platforms = [];\n    this.generatePlatforms();\n\n    this.human = human;\n  }\n\n  generatePlatforms(){\n    this.platforms.push(\n      new Platform(-1360, 550, 600, 15)\n    );\n    while(\n      this.platforms[this.platforms.length - 1].xStart +\n      this.platforms[this.platforms.length - 1].width < 2000){\n        let prevPlat = this.platforms[this.platforms.length - 1];\n        let newYStart = this.generatePlatformYStart();\n        if(newYStart - prevPlat.yStart > 50){\n          newYStart = prevPlat.yStart + 50;\n        }\n        this.platforms.push(\n          new Platform(\n            prevPlat.xStart + prevPlat.width + this.generatePlatformGap(),\n            newYStart,\n            this.generatePlatformWidth(),\n            15\n          ));\n      }\n  }\n\n  generatePlatformYStart(){\n    if(this.platforms.length === 0){\n      return 550;\n    }else{\n      let prevPlatHeight = this.platforms[this.platforms.length - 1].yStart;\n      let randomOffset = Math.round(Math.random() * 150);\n      if(randomOffset < 30){\n        randomOffset = 50;\n      }\n      let randHeight;\n      if(Math.random() < 0.5){\n        randHeight = prevPlatHeight + randomOffset;\n      }else{\n        randHeight = prevPlatHeight - randomOffset;\n      }\n      if(randHeight < 350){\n        randHeight = 350;\n      }else if(randHeight > 625){\n        randHeight = 625;\n      }\n      return randHeight;\n    }\n  }\n\n  generatePlatformWidth(){\n    let randomOffset = Math.round(Math.random() * 200);\n    // let randomNegOffset = Math.round(Math.random() * (200 * (-1)));\n    let randNum = Math.random();\n    if(randNum < .5){\n      return 400 + randomOffset;\n    }else{\n      return 400 - randomOffset;\n    }\n  }\n\n  generatePlatformGap(){\n    return Math.round(Math.random() * 100) + 100;\n  }\n\n  // --------------------------------------------------------------------------\n  // --------------------------------------------------------------------------\n  // --------------------------------------------------------------------------\n  // --------------------------------------------------------------------------\n  // --------------------------------------------------------------------------\n  // --------------------------------------------------------------------------\n\n  animate(context){\n    this.draw(context);\n    this.action();\n  }\n\n  action(){\n    this.move();\n  }\n\n  move(){\n    let that = this;\n    if(this.human.xPos >= 800 && this.human.xVel > 0){\n      this.platforms.forEach((plat) => {\n        // plat.move(that.human.xVel * (-1) - .1, 0);\n        plat.move(that.human.xVel * (-1), 0);\n      });\n    }else if(this.human.xPos <= 300 && this.human.xVel < 0){\n      this.platforms.forEach((plat) => {\n        // plat.move(this.human.xVel * (-1) + .1, 0);\n        plat.move(this.human.xVel * (-1), 0);\n      });\n    }\n    if(this.platforms[0].xStart < -1450){\n      this.platforms.shift();\n      let prevPlat = this.platforms[this.platforms.length - 1];\n      this.platforms.push(\n        new Platform(\n          prevPlat.xStart + prevPlat.width + this.generatePlatformGap(),\n          this.generatePlatformYStart(),\n          this.generatePlatformWidth(),\n          15\n        ));\n    }else if(this.platforms[this.platforms.length - 1].xStart > 1300){\n      this.platforms.pop();\n      let newPlatWidth = this.generatePlatformWidth();\n      let nextPlat = this.platforms[0];\n      this.platforms.unshift(\n        new Platform(\n          nextPlat.xStart - this.generatePlatformGap() - newPlatWidth,\n          this.generatePlatformYStart(),\n          newPlatWidth,\n          15\n        ));\n    }\n  }\n\n  draw(context){\n    this.platforms.forEach((p) => {\n      p.draw(context);\n    });\n    \n    \n\n  }\n\n}","\n\nexport default class Projectile{\n  // constructor(id, playerXVel, playerPos, context, xVel, yVel){\n  constructor(player, projectileXVel, projectileYVel, homing=false, human=null){\n\n    this.homing = homing;\n\n    this.human = human;\n    this.owner = player.type;\n    this.context = player.context;\n\n    this.didHit = false;\n\n    this.playerXVel = player.xVel;\n    this.playerXPos = player.xPos;\n    this.playerYPos = player.yPos;\n\n    this.xPos = player.xPos;\n    this.yPos = player.yPos;\n    this.xVel = projectileXVel;\n    this.yVel = projectileYVel;\n    if(player.type === 'human'){\n      this.width = 5;\n      this.height = 5;\n    }else{\n      if(homing){\n        this.width = 15;\n        this.height = 15;  \n      }else{\n        this.width = 5;\n        this.height = 5;\n      }\n    }\n    this.alive = true;\n    this.id = player.projectileCount;\n  }\n  \n  animate(context, xVel=null, yVel=null){\n    if(this.owner === 'computer'){\n      if(this.homing === true){\n        this.homingMove(xVel, yVel);\n        this.homingDraw(context);\n      }else{\n        this.computerProjectileMove();\n        this.draw(context);\n      }\n    }else{\n      this.humanProjectileMove();\n      this.draw(context);\n    }\n  }\n  \n  humanProjectileMove(){\n    if((this.playerXPos >= 800 && this.playerXVel >= 0)){\n      this.xPos += this.xVel;\n      if(this.owner === 'computer'){\n        this.xPos -= (this.playerXVel / 2);\n      }\n      this.yPos += this.yVel;\n    } else if ((this.playerXPos <= 300 && this.playerXVel <= 0)){\n      this.xPos += this.xVel;\n      if(this.owner === 'computer'){\n        this.xPos -= (this.playerXVel / 2);\n      }\n      this.yPos += this.yVel;\n    }else{\n      this.xPos += this.xVel;\n      this.yPos += this.yVel;\n    }\n  }\n\n  computerProjectileMove(){\n    if((this.human.xPos >= 800 && this.human.xVel >= 0)){\n      this.xPos += this.xVel;\n      if(this.owner === 'computer'){\n        this.xPos -= (this.human.xVel / 2);\n      }\n      this.yPos += this.yVel;\n    } else if ((this.human.xPos <= 300 && this.human.xVel <= 0)){\n      this.xPos += this.xVel;\n      if(this.owner === 'computer'){\n        this.xPos -= (this.human.xVel / 2);\n      }\n      this.yPos += this.yVel;\n    }else{\n      this.xPos += this.xVel;\n      this.yPos += this.yVel;\n    }\n  }\n\n  homingMove(xVel, yVel){\n\n    if((this.human.xPos >= 800 && this.human.xVel >= 0)){\n      this.xPos += xVel;\n      if(this.owner === 'computer'){\n        this.xPos -= (this.human.xVel / 2);\n      }\n      this.yPos += yVel;\n    } else if ((this.human.xPos <= 300 && this.human.xVel <= 0)){\n      this.xPos += xVel;\n      if(this.owner === 'computer'){\n        this.xPos -= (this.human.xVel / 2);\n      }\n      this.yPos += yVel;\n    }else{\n      this.xPos += xVel;\n      this.yPos += yVel;\n    }\n\n    // console.log(xVel);\n    // console.log(yVel);\n  }\n\n\n  draw(context){\n    if(!this.didHit){\n      if(this.owner === 'human'){\n        context.fillStyle = 'black';\n        context.fillRect(this.xPos, this.yPos, this.width, this.height);  \n      }else{\n        context.fillStyle = 'white';\n        context.fillRect(this.xPos, this.yPos, this.width, this.height);\n      }\n    }\n  }\n\n  homingDraw(context) {\n    if (!this.didHit) {\n      context.fillStyle = 'green';\n      context.fillRect(this.xPos, this.yPos, this.width, this.height);\n    }\n  }\n\n}","import Projectile from \"./projectile\";\n\nexport default class Human{\n\tconstructor(environment, context, computerProjectiles){\n\t\tthis.type = 'human';\n\n\t\tthis.CONSTANTS = {\n\t\t\tGRAVITY: 0.5,\n\t\t\tNORMALFORCE: -0.5\n\t\t};\n\n\t\tthis.alive = true;\n\t\tthis.projectiles = {};\n\t\tthis.environment = environment;\n\t\tthis.context = context;\n\t\tthis.computerProjectiles = computerProjectiles;\n\t\tthis.jumping = false;\n\t\tthis.projectileCount = 0;\n\n\t\tthis.additionalScore = 0;\n\n\t\tthis.curJumps = 0;\n\t\tthis.dashes = 0;\n\n    this.xPos = 350;\n    this.yPos = 100;\n    this.yVel = 0;\n    this.xVel = 0;\n    this.width = 15;\n\t\tthis.height = 15;\n\t\t\n\t\tthis.onFloor = false;\n\t\tthis.curPlat = null;\n\t\tthis.lastPlat = this.environment.platforms[0];\n\n\t\tthis.movingLeft = false;\n\t\tthis.movingRight = false;\n\t\tthis.goingDown = false;\n\n\t\tthis.distanceCovered = 0;\n\n\t\tthis.bindLeft();\n\t\tthis.bindRight();\n\t\tthis.bindUndoRight();\n\t\tthis.bindUndoLeft();\n\t\tthis.bindDown();\n\t\tthis.bindUndoDown();\n\t\tthis.bindDash();\n\n    this.bindJump();\n    this.setClick = this.setClick.bind(this);\n    this.setClick(this);\n\t}\n\t// ----------------------------------------------------------------------------------------------------\n\t// ----------------------------------MAIN---------------------------------------------------\n\t// ----------------------------------MAIN--------------------------------------------------------------\n\t// ----------------------------------MAIN--------------------------------------------------------------\n\t// ----------------------------------MAIN--------------------------------------------------------------\n\t// ----------------------------------MAIN--------------------------------------------------------------\n\t// ----------------------------------MAIN--------------------------------------------------------------\n\n\t// filterProjectiles(){\n\t// \tlet newProjectiles = {};\n\t// \tlet that = this;\n\t// \tObject.keys(this.projectiles).forEach((key) => {\n\t// \t\tif(that.projectiles[key].yPos < 710 && that.projectiles[key].yPos > -10){\n\t// \t\t\tlet projectile = {[key]: that.projectiles[key]}\n\t// \t\t\tnewProjectiles = Object.assign(projectile, newProjectiles);\n\t// \t\t}\n\t// \t})\n\t// \tthis.projectiles = newProjectiles;\n\t// }\n\n\n\tanimate(context) {\n\t\tthis.move();\n\t\tthis.draw(context);\n\t\t// if (Object.values(this.projectiles).length > 0) {\n\t\t// \tObject.values(this.projectiles).forEach((p) => {\n\t\t// \t\tp.animate(context);\n\t\t// \t});\n\t\t// }\n\t\t// this.filterProjectiles();\n\t\t// this.collidedWithProjectiles();\n\t}\n\n\tdraw(context) {\n\t\tcontext.fillStyle = 'gray';\n\t\tcontext.fillRect(\n\t\t\tthis.xPos, this.yPos, this.width, this.height\n\t\t);\n\t}\n\n\tmove(){\n\t\t// if player is no longer 'alive', then apply gravity until they fall off screen\n\t\tif(!this.alive){\n\t\t\tthis.applyGravity();\n\t\t\tthis.yPos += this.yVel;\n\t\t\treturn;\n\t\t}\n\n\t\t// check whether or not the player is above a platform, and if so, which platform\n\t\tthis.getCurrentPlatform();\n\n\t\t// if player is above a platform, set jumping flag to false based on velocity and position\n\t\t// if player is not above a platform, set onfloor flag to false\n\t\tif(this.curPlat){\n\t\t\tif(this.yVel > 0 && this.yPos < (this.curPlat.yStart - 20 || this.lastPlat.yStart) ){\n\t\t\t\tthis.jumping = false;\n\t\t\t}\n\t\t}else if(!this.curPlat){\n\t\t\tthis.onFloor = false;\n\t\t}\n\t\t// check whether or not the player is above a platform, and if so, which platform\n\t\tthis.getCurrentPlatform();\n\n\t\t// if player is onfloor and not jumping, reset dashes and jumps, set yPos platform plus player height,\n\t\t// set yVel to zero, and apply horizontal movement based on whether or not player has reached the designated side zones\n\t\tif(this.onFloor && !this.jumping){\n\t\t\tthis.dashes = 0;\n\t\t\tthis.curJumps = 0;\n\t\t\tthis.yPos = this.curPlat.yStart - this.height;\n\t\t\tthis.yVel = 0;\n\t\t\tthis.isPlayerOnSide();\n\t\t// if player is not yet 'onfloor', but is above a platform, check ypos to see whether onfloor flag should be set to true\n\t\t// apply horizontal movement based on whether or not player has reached the designated side zones\n\t\t// whether or not player is above a platform, apply gravity\n\t\t}else if(!this.onFloor){\n\t\t\tif(this.curPlat){\n\t\t\t\tif(this.yPos >= this.curPlat.yStart - this.height && this.yVel >= 0){\n\t\t\t\t\tthis.onFloor = true;\n\t\t\t\t\tthis.isPlayerOnSide();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.yVel += this.CONSTANTS.GRAVITY;\n\t\t\tthis.yPos += this.yVel;\n\t\t\tthis.isPlayerOnSide();\n\t\t// if player is onfloor but jumping, have them leave the floor, circumventing the floor-stick effect\n\t\t}else if(this.onFloor && this.jumping){\n\t\t\tthis.yPos += this.yVel;\n\t\t\tthis.isPlayerOnSide();\n\t\t}\n\t\t// apply friction to player movement to slow them down if no movement keys are being pressed.\n\t\tif(!this.movingLeft && !this.movingRight){\n\t\t\tif(this.xVel > 0){\n\t\t\t\tthis.xVel -= .3;\n\t\t\t}else if(this.xVel < 0){\n\t\t\t\tthis.xVel += .3;\n\t\t\t}\n\t\t}\n\t\t// add change in xPos to total distance covered, will be used to change rounds\n\t\tthis.distanceCovered += this.xVel;\n\t}\n\n\t// if player is at 300 or 800 px, stop horizontal movement to avoid leaving screen and give player\n\t// a view of upcoming obstacles\n\tisPlayerOnSide(){\n\t\tif ((this.xPos >= 800 && this.xVel >= 0) || (this.xPos <= 300 && this.xVel <= 0)) {\n\t\t\tnull;\n\t\t} else {\n\t\t\tthis.xPos += this.xVel;\n\t\t}\n\t}\n\n\t// --------------------------------------------------------------------------------------------------\n\t// ----------------------BASIC UTIL---------------------------------------------------------------\n\t// ----------------------BASIC UTIL---------------------------------------------------------------\n\t// ----------------------BASIC UTIL---------------------------------------------------------------\n\t// ----------------------BASIC UTIL---------------------------------------------------------------\n\t// ----------------------BASIC UTIL---------------------------------------------------------------\n\t// ----------------------BASIC UTIL---------------------------------------------------------------\n\tapplyGravity(){\n\t\tthis.yVel += this.CONSTANTS.GRAVITY;\n\t}\n\n\tisInAir(){\n\t\tif(!this.curPlat){\n\t\t\treturn true;\n\t\t}\n\t\tif(this.yPos < (this.curPlat.yStart - this.height)){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tisOnFloor(){\n\t\tif(!this.curPlat){\n\t\t\treturn false;\n\t\t}\n\t\tif(this.yPos > (this.curPlat.yStart - this.curPlat.height)){\n\t\t\tif(this.yPos < (this.curPlat.yStart + 5)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --------------------------------------------------------------------------------------------------\n\t// ----------------------COLLISION LOGIC---------------------------------------------------------------\n\t// ----------------------COLLISION LOGIC---------------------------------------------------------------\n\t// ----------------------COLLISION LOGIC---------------------------------------------------------------\n\t// ----------------------COLLISION LOGIC---------------------------------------------------------------\n\t// ----------------------COLLISION LOGIC---------------------------------------------------------------\n\t// ----------------------COLLISION LOGIC---------------------------------------------------------------\n\n\tcollidedWithFloor() {\n\t\tif (this.curPlat) {\n\t\t\tif (this.yPos >= this.curPlat.yStart - 10) {\n\t\t\t\tthis.onFloor = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// checks if player xPos is between the left and right edges of any platform('above platform')\n\tgetCurrentPlatform() {\n\t\t// \n\t\tlet that = this;\n\t\tfor (let i = 0; i < this.environment.platforms.length; i++) {\n\t\t\tlet plat = that.environment.platforms[i];\n\t\t\tif (that.xPos > plat.xStart && that.xPos < plat.xStart + plat.width && that.yPos < plat.yStart + plat.height) {\n\t\t\t\t\n\t\t\t\tthat.curPlat = plat;\n\t\t\t\tthat.lastPlat = that.curPlat;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tthat.curPlat = null;\n\t\t\t\t// that.onFloor = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ----------------------------------------------------------------------------------------------------\n\t// -------------------------MOVEMENT BINDS--------------------------------------------------------------------------\n\t// -------------------------MOVEMENT BINDS---------------------------------------------------------------------------\n\t// -------------------------MOVEMENT BINDS---------------------------------------------------------------------------\n\t// -------------------------MOVEMENT BINDS-------------------------------------------------------------\n\t// -------------------------MOVEMENT BINDS---------------------------------------------------------------------------\n\t// -------------------------MOVEMENT BINDS---------------------------------------------------------------------------\n\n\tbindLeft() {\n\t\twindow.addEventListener('keypress', (e) => {\n\t\t\tif (e.key === 'a') {\n\t\t\t\tthis.moveLeft();\n\t\t\t\tthis.movingLeft = true;\n\t\t\t\tthis.movingRight = false;\n\t\t\t}\n\t\t});\n\t}\n\n\tbindUndoLeft(){\n\t\twindow.addEventListener('keyup', (e) => {\n\t\t\tif (e.key === 'a') {\n\t\t\t\t// this.moveLeft();\n\t\t\t\tthis.movingLeft = false;\n\t\t\t}\n\t\t});\n\t}\n\n\tbindRight(){\n\t\twindow.addEventListener('keypress', (e) => {\n\t\t\tif (e.key === 'd') {\n\t\t\t\tthis.moveRight();\n\t\t\t\tthis.movingRight = true;\n\t\t\t\tthis.movingLeft = false;\n\t\t\t}\n\t\t});\n\t}\n\n\tbindUndoRight(){\n\t\twindow.addEventListener('keyup', (e) => {\n\t\t\tif (e.key === 'd') {\n\t\t\t\t// this.moveRight();\n\t\t\t\tthis.movingRight = false;\n\t\t\t}\n\t\t});\n\t}\n\n\tbindJump() {\n\t\twindow.addEventListener('keypress', (e) => {\n\t\t\tif (e.key === 'w') {\n\t\t\t\tthis.jump();\n\t\t\t}\n\t\t});\n\t}\n\n\tbindDown(){\n\t\twindow.addEventListener('keypress', (e) => {\n\t\t\tif(e.key === 's'){\n\t\t\t\tthis.goingDown = true;\n\t\t\t\tthis.down();\n\t\t\t}\n\t\t});\n\t}\n\n\tbindUndoDown(){\n\t\twindow.addEventListener('keyup', (e) => {\n\t\t\tif (e.key === 's') {\n\t\t\t\t// this.down();\n\t\t\t\tthis.goingDown = false;\n\t\t\t}\n\t\t});\n\t}\n\n\t// loop sets five timeouts in order to gradually slow down player after dashing\n\tbindDash(){\n\t\twindow.addEventListener('keypress', (e) => {\n\t\t\tif(e.key === 'Spacebar' || e.key === ' '){\n\t\t\t\tif(this.dashes > 0){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(this.movingLeft){\n\t\t\t\t\tthis.xVel -= 7.5;\n\t\t\t\t\tthis.dashes += 1;\n\t\t\t\t\tfor(let i = 0; i < 5; i++){\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tthis.xVel += 1.5;\n\t\t\t\t\t\t}, 100 * i)\n\t\t\t\t\t}\n\t\t\t\t}else if(this.movingRight){\n\t\t\t\t\tthis.xVel += 7.5;\n\t\t\t\t\tthis.dashes += 1;\n\t\t\t\t\tfor(let i = 0; i < 5; i++){\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tthis.xVel -= 1.5;\n\t\t\t\t\t\t}, 100 * i)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\n\n// ----------------------------------------------------------------------------------------------------\n// -------------------------PROJECTILE BIND AND CONFIG--------------------------------------------------------------------------\n// -------------------------PROJECTILE BIND AND CONFIG---------------------------------------------------------------------------\n// -------------------------PROJECTILE BIND AND CONFIG---------------------------------------------------------------------------\n// -------------------------PROJECTILE BIND AND CONFIG-------------------------------------------------------------\n// -------------------------PROJECTILE BIND AND CONFIG---------------------------------------------------------------------------\n// -------------------------PROJECTILE BIND AND CONFIG---------------------------------------------------------------------------\n\n\t// if player clicks, fetch click coordinates, wrap them in an object, create a projectile with the result\n\t// of passing that object into configureProjectile\n\tsetClick(that) {\n\t\tthis.context.canvas.addEventListener('click', (e) => {\n\t\t\tlet rect = this.context.canvas.getBoundingClientRect();\n\t\t\tlet pos = {};\n\t\t\tpos.x = e.clientX - rect.left;\n\t\t\tpos.y = e.clientY - rect.top;\n\n\t\t\tlet newProj = new Projectile(that, ...that.configureProjectile(pos));\n\t\t\tlet newId = newProj.id;\n\t\t\tthat.projectiles = Object.assign({[newId]: newProj}, that.projectiles);\n\n\t\t\tthis.projectileCount += 1;\n\t\t});\n\t}\n\n\t// calculates the necessary x and y velocities for the projectile(starting at player position)\n\t// to get to the coordinates of the click\n\tconfigureProjectile(pos){\n\t\tlet xDelta = pos.x - this.xPos;\n\t\tlet yDelta = pos.y - this.yPos;\n\n\t\tlet squaredDeltaX = Math.pow(xDelta, 2);\n\t\tlet squaredDeltaY = Math.pow(yDelta, 2);\n\t\tlet totalDeltasquared = squaredDeltaX + squaredDeltaY;\n\t\tlet totalDelta = Math.sqrt(totalDeltasquared);\n\n\t\tlet proportion = 20 / totalDelta;\n\t\tlet xVel = xDelta * proportion;\n\t\tlet yVel = yDelta * proportion;\n\n\t\treturn [xVel, yVel];\n\t}\n\t// ----------------------------------------------------------------------------------------------------\n\t// -------------------------MOVEMENT--------------------------------------------------------------------------\n\t// -------------------------MOVEMENT---------------------------------------------------------------------------\n\t// -------------------------MOVEMENT---------------------------------------------------------------------------\n\t// -------------------------MOVEMENT-------------------------------------------------------------\n\t// -------------------------MOVEMENT---------------------------------------------------------------------------\n\t// -------------------------MOVEMENT---------------------------------------------------------------------------\n\n\tjump(){\n\t\tif(this.curJumps < 2){\n\t\t\tthis.onFloor = false;\n\t\t\tthis.jumping = true;\n\t\t\tthis.yVel = -12;\n\t\t\tthis.curJumps += 1;\n\t\t}\n\t}\n\n\tmoveRight(){\n\t\tthis.xVel = 5;\n\t}\n\n\tmoveLeft() {\n\t\tthis.xVel = -5;\n\t}\n\n\tdown(){\n\t\tif(this.goingDown === true){\n\t\t\tthis.yVel += 5;\n\t\t}\n\t}\n\n\t// ----------------------------------------------------------------------------------------------------\n\t// ----------------------------------------------------------------------------------------------------\n\t// ----------------------------------------------------------------------------------------------------\n\t// ----------------------------------------------------------------------------------------------------\n\t// ----------------------------------------------------------------------------------------------------\n\t// ----------------------------------------------------------------------------------------------------\n\t// ----------------------------------------------------------------------------------------------------\n\t\n\n\t// commented out text is using four-corner detection, which is buggy, perhaps to small projectile sizes?\n\tcollide(obj1, obj2) {\n\t\t// let obj1TopLeft = {x : obj1.xPos, y: obj1.yPos};\n\t\t// let obj1TopRight = { x: obj1.xPos + obj1.width, y: obj1.yPos };\n\t\t// let obj1BotLeft = { x: obj1.xPos, y: obj1.yPos + obj1.height };\n\t\t// let obj1BotRight = { x : obj1.xPos + obj1.width, y : obj1.yPos + obj1.height};\n\n\t\t\n\t\t// let obj2TopLeft = {x : obj2.xPos, y : obj2.yPos};\n\t\t// let obj2TopRight = { x: obj2.xPos + obj2.width, y: obj2.yPos };\n\t\t// let obj2BotLeft = { x: obj2.xPos, y: obj2.yPos + obj2.height };\n\t\t// let obj2BotRight = {x : obj2.xPos + obj2.width, y : obj2.yPos + obj2.height};\n\n\t\tlet obj1CenterX = obj1.xPos + (obj1.width / 2);\n\t\tlet obj1CenterY = obj1.yPos + (obj1.height / 2);\n\t\tlet obj1Diag = Math.sqrt(Math.pow(obj1.width / 2, 2) + Math.pow(obj1.height / 2, 2));\n\n\t\tlet obj2CenterX = obj2.xPos + (obj2.width / 2);\n\t\tlet obj2CenterY = obj2.yPos + (obj2.height / 2);\n\t\tlet obj2Diag = Math.sqrt(Math.pow(obj2.width / 2, 2) + Math.pow(obj2.height / 2, 2));\n\n\t\tlet totalDelta = Math.sqrt(Math.pow(obj1CenterX - obj2CenterX, 2) + Math.pow(obj1CenterY - obj2CenterY, 2))\n\n\t\t// this is using top right pos, should be using center, but probably doesnt matter\n\t\t// let totalDelta = Math.sqrt(Math.pow(obj1.xPos - obj2.xPos, 2) + Math.pow(obj1.yPos - obj2.yPos, 2));\n\n\t\t// let totalDelta = Math.sqrt(Math.pow(obj1CenterX - obj2CenterX))\n\n\t\t// if((obj1TopLeft.x < obj2BotRight.x && obj1TopLeft.y < obj2BotRight.y) &&\n\t\t//   (obj1Diag + obj2Diag > totalDelta)){\n\t\t//   return true;\n\t\t// } else if (obj1TopRight.x > obj2BotLeft.x && obj1TopRight.y > obj2BotLeft.y && (obj1Diag + obj2Diag > totalDelta)){\n\t\t//   return true;\n\t\t// } else if (obj1BotRight.x > obj2TopLeft.x && obj1BotRight.y > obj2TopLeft.y && (obj1Diag + obj2Diag > totalDelta)){\n\t\t//   return true;\n\t\t// } else if (obj1BotLeft.x < obj2TopRight.x && obj1BotLeft.y > obj2TopRight.y && (obj1Diag + obj2Diag > totalDelta)){\n\t\t//   return true;\n\t\t// }else{\n\t\t//   return false;\n\t\t// }\n\n\t\tif(obj1Diag + obj2Diag + 10 > totalDelta) {\n\t\t\t// debugger;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n\t// collidedWithProjectiles() {\n\t// \tlet that = this;\n\t// \tObject.values(this.computerProjectiles).forEach((p) => {\n\t// \t\tif (that.collide(that, p)) {\n\t// \t\t\tdebugger;\n\t// \t\t\tp.didHit = true;\n\t// \t\t\tthat.alive = false;\n\t// \t\t}\n\t// \t});\n\t// }\n\n\t// ----------------------------------------------------------------------------------------------------\n\t// ----------------------------------------------------------------------------------------------------\n\t// ----------------------------------------------------------------------------------------------------\n\t// ----------------------------------------------------------------------------------------------------\n\t// ----------------------------------------------------------------------------------------------------\n\t// ----------------------------------------------------------------------------------------------------\n\t// ----------------------------------------------------------------------------------------------------\n\n}","\n\nexport default class Background{\n  constructor(dimensions, round=0){\n    this.dimensions = dimensions;\n    this.round = round;\n\n    this.colors = [\n      '#5eaec4',\n      'green',\n      'orange',\n      'blue'\n    ];\n  }\n\n  setRound(num){\n    this.round = num;\n  }\n\n  draw(context){\n    context.fillStyle = this.colors[this.round];\n    context.fillRect(0, 0, this.dimensions.width, this.dimensions.height);\n  }\n\n  animate(context){\n    this.draw(context);\n  }\n}","import Projectile from \"./projectile\";\n\nexport default class Computer{\n  constructor(environment, context, human, counterOffset, xPos=850){\n    this.type = 'computer';\n\n\t\tthis.CONSTANTS = {\n      GRAVITY: 0.5,\n      JETPACK: 0.5\n    };\n\n    this.alive = true;\n\t\tthis.environment = environment;\n    this.context = context;\n    this.projectiles = {};\n    this.humanProjectiles = human.projectiles;\n\n    this.additionalScore = 0;\n    this.projectileCount = 10000 + counterOffset;\n\n\t\tthis.xPos = xPos;\n    this.yPos = 100;\n\t\tthis.yVel = 0;\n\t\tthis.xVel = -5;\n\t\tthis.width = 30;\n    this.height = 30;\n    \n    this.human = human;\n\n    this.canShoot = false;\n    this.initiateShot();\n\n\t}\n\n  // ------------------------------------------------------------\n\n\n  // filterProjectiles(){\n  //   let projectiles = Object.values(this.projectiles).filter(p => p.didHit === true);\n  //   projectiles.forEach((p) => {\n  //     let id = p.id;\n  //     delete this.projectiles[id];\n  //   })\n  // }\n\n  // filterHomingProjectiles(){\n  //   let homingProjectiles = Object.values(this.projectiles).filter(p => p.homing === true);\n  //   Object.values(homingProjectiles).forEach((hp) => {\n  //     let id = hp.id;\n  //     if(hp.alive === false){\n  //       delete this.projectiles[id];\n  //     }\n  //   })\n  // }\n\n  initiateShot(){\n    window.setInterval(() => {\n      this.shoot();\n    }, 2000);\n  }\n\n  switchDirection(){\n    if(this.xPos <= 20){\n      this.xVel = 5;\n    }else if(this.xPos >= 1080){\n      this.xVel = -5;\n    }\n  }\n\n  // fetchHumanPosition(){\n  //   this.playerPosX = this.human.xPos;\n  //   this.playerPosY = this.human.yPos;\n  // }\n\n  shoot(){\n    let pos = {};\n    // pos.x = this.playerPosX;\n    // pos.y = this.playerPosY;\n    pos.x = this.human.xPos;\n    pos.y = this.human.yPos;\n\n    let newProj;\n    \n    let randNum = Math.round(Math.random() * 10);\n    if(randNum >= 8){\n      newProj = (\n        new Projectile(\n          this,\n          ...this.configureProjectile(pos),\n          true,\n          this.human\n        )\n      );\n    }else{\n      newProj = (\n        new Projectile(\n          this,\n          ...this.configureProjectile(pos),\n          false,\n          this.human\n        )\n      );\n    }\n        \n    this.projectiles[newProj.id] = newProj;\n    this.projectileCount += 1;\n  }\n\n\tconfigureProjectile(pos, homing=false, projectile=null){\n    let randNum = Math.random();\n    \n    let xDelta;\n    let yDelta;\n\n    // if projectile is homing, we need to call this method and compare the projectile's\n    // current position with that of the human player, else we are comparing the player and the computer\n    if(homing === false){\n      xDelta = pos.x - this.xPos;\n      yDelta = pos.y - this.yPos;\n    }else if(homing === true){\n      xDelta = pos.x - projectile.xPos;\n      yDelta = pos.y - projectile.yPos;\n    }\n\n    if(homing === false){\n      let randOffset = Math.round(Math.random() * 200);\n      if(randNum < 0.25){\n        xDelta += randOffset;\n      }else if(randNum > 0.25 && randNum < 0.5){\n        xDelta -= randOffset;\n      }\n    }\n\n    let squaredDeltaX = Math.pow(xDelta, 2);\n    let squaredDeltaY = Math.pow(yDelta, 2);\n    let totalDeltasquared = squaredDeltaX + squaredDeltaY;\n    let totalDelta = Math.sqrt(totalDeltasquared);\n\n    let proportion;\n    if(projectile === null){\n      proportion = 5 / totalDelta;\n    }else{\n      proportion = 3 / totalDelta;\n    }\n    let xVel = xDelta * proportion;\n    let yVel = yDelta * proportion;\n\n    return [xVel, yVel];\n  }\n\n\n  // ------------------------------------------------------------\n\n  jump(){\n    this.yVel -= 5;\n  }\n\n  moveRight(){\n    this.xVel += 2;\n    if(this.xVel > 5){\n      this.xVel = 5;\n    }\n  }\n\n  moveLeft() {\n    this.xVel -= 2;\n    if (this.xVel < -5) {\n      this.xVel = -5;\n    }\n\t}\n  // ------------------------------------------------------------\n\n\tdraw(context){\n    context.fillStyle = 'red';\n    context.fillRect(\n      this.xPos, this.yPos, this.width, this.height\n    );\n  }\n\n  action(){\n    this.move();\n    // this.fetchHumanPosition();\n    if(this.alive){\n      this.switchDirection();\n      // this.collidedWithProjectiles();\n    }\n  }\n\n  move(){\n    if(!this.alive){\n      this.yVel += this.CONSTANTS.GRAVITY;\n      this.yPos += this.yVel;\n    }else{\n      this.yPos += this.yVel;\n      this.xPos += this.xVel;\n      if(this.collidedWithFloor() !== true){\n        this.yVel += this.CONSTANTS.GRAVITY;\n        this.yVel -= this.CONSTANTS.JETPACK;\n      }\n      if(this.xVel > 0 && this.collidedWithFloor()){\n        this.xVel -= 0.1;\n      } else if (this.xVel < 0 && this.collidedWithFloor()){\n        this.xVel += 0.1;\n      }\n    }\n    if(this.human.xPos >= 800){\n      if(this.xVel <= 0){\n        // this.xPos -= 1;\n      }\n    }else if(this.human.xPos <= 300){\n      if (this.human.xPos <= 300){\n        // this.xPos += 1;\n      }\n    }\n  }\n  // ------------------------------------------------------------\n  // animate(context, human){\n    animate(context){\n    this.action();\n    this.draw(context);\n    // this.filterHomingProjectiles();\n    // let pos;\n    // if(Object.values(this.projectiles).length > 0){\n    //   Object.values(this.projectiles).forEach((p) => {\n    //     if(p.homing === true){\n    //       pos = {x: human.xPos, y: human.yPos};\n    //       p.animate(context, ...this.configureProjectile(pos, true, p));\n    //     }else{\n    //       p.animate(context);\n    //     }\n    //   });\n    // }\n    // this.projectiles = this.projectiles.filter(p => p.xPos < 1110 && p.xPos > -10 && p.yPos > -10 && p.yPos < 410);\n    // Object.values(this.projectiles).forEach((p) => {\n    //   if (!(p => p.xPos < 1110 && p.xPos > -10 && p.yPos > -10 && p.yPos < 710)){\n    //     delete this.projectiles[p.id];\n    //   }\n    // });\n  }\n  // ------------------------------------------------------------\n  collidedWithFloor(){\n    if(this.yPos >= this.environment.height - 13){\n      this.yVel = 0;\n      return true;\n    }\n  }\n\n  collide(obj1, obj2){\n    // let obj1TopLeft = {x : obj1.xPos, y: obj1.yPos};\n    // let obj1TopRight = { x: obj1.xPos + obj1.width, y: obj1.yPos };\n    // let obj1BotLeft = { x: obj1.xPos, y: obj1.yPos + obj1.height };\n    // let obj1BotRight = { x : obj1.xPos + obj1.width, y : obj1.yPos + obj1.height};\n\n    let obj1Diag = Math.sqrt(Math.pow(obj1.width / 2, 2) + Math.pow(obj1.height / 2, 2)) / 2;\n\n    // let obj2TopLeft = {x : obj2.xPos, y : obj2.yPos};\n    // let obj2TopRight = { x: obj2.xPos + obj2.width, y: obj2.yPos };\n    // let obj2BotLeft = { x: obj2.xPos, y: obj2.yPos + obj2.height };\n    // let obj2BotRight = {x : obj2.xPos + obj2.width, y : obj2.yPos + obj2.height};\n\n    let obj2Diag = Math.sqrt(Math.pow(obj2.width / 2, 2) + Math.pow(obj2.height / 2, 2)) / 2;\n\n    let totalDelta = Math.sqrt(Math.pow(obj1.xPos - obj2.xPos, 2) + Math.pow(obj1.yPos - obj2.yPos, 2));\n    \n    // if((obj1TopLeft.x < obj2BotRight.x && obj1TopLeft.y < obj2BotRight.y) &&\n    //   (obj1Diag + obj2Diag > totalDelta)){\n    //   return true;\n    // } else if (obj1TopRight.x > obj2BotLeft.x && obj1TopRight.y > obj2BotLeft.y && (obj1Diag + obj2Diag > totalDelta)){\n    //   return true;\n    // } else if (obj1BotRight.x > obj2TopLeft.x && obj1BotRight.y > obj2TopLeft.y && (obj1Diag + obj2Diag > totalDelta)){\n    //   return true;\n    // } else if (obj1BotLeft.x < obj2TopRight.x && obj1BotLeft.y > obj2TopRight.y && (obj1Diag + obj2Diag > totalDelta)){\n    //   return true;\n    // }else{\n    //   return false;\n    // }\n    \n    \n    if(obj1Diag + obj2Diag + 10 > totalDelta){\n      return true;\n    }else{\n      return false;\n    }\n\n  }\n\n  // collidedWithProjectiles(){\n    // check for computer player collision with human player projectiles\n    // Object.values(this.human.projectiles).forEach((hp) => {\n    //   if(this.collide(this, hp)){\n    //     hp.didHit = true;\n    //     this.alive = false;\n    //     this.additionalScore += 1;\n    //     return true;\n    //   }\n    // });\n    // // check for computer homing missle collision with human player projectiles\n    // let homingMissles = Object.values(this.projectiles).filter(p => p.homing === true);\n    // homingMissles.forEach((hm) => {\n    //   Object.values(this.human.projectiles).forEach((hp) => {\n    //     if(this.collide(hm, hp)){\n    //       hp.didHit = true;\n    //       hm.alive = false;\n    //       return true;\n    //     }\n    //   })\n    // })\n  // }\n\n\n}","\n\nexport default class Score{\n  constructor(context, initScore=0){\n    this.xPos = 1050;\n    this.yPos = 100;\n    this.score = initScore;\n\n    this.context = context;\n  }\n\n  animate(){\n    this.draw();\n  }\n\n  draw(){\n    this.context.font = \"20px Arial\";\n    this.context.fillText(this.score, this.xPos, this.yPos);\n  }\n}","\n\nexport default class LandComputer{\n  constructor(environment, context, human, posOffset){\n    this.environment = environment;\n    this.context = context;\n    this.human = human;\n\n    let positions = this.getStartPlatforms();\n\n    let randNum = Math.random();\n    if(randNum > 0.5){\n      this.xPos = positions.left.xStart + ((positions.left.width / 2));\n      this.goingRight = true;\n      this.goingLeft = false;\n      this.xVel = 4;\n    }else{\n      this.xPos = positions.right.xStart + ((positions.right.width / 2));\n      this.goingLeft = true;\n      this.goingRight = false;\n      this.xVel = -4;\n    }\n    this.getCurrentPlatform();\n    this.yPos = this.curPlat.yStart;\n    this.yVel = 0;\n    this.CONSTANTS = {\n      GRAVITY: 0.5,\n    };\n\n    this.height = 30;\n    this.width = 30;\n    this.projectiles = {};\n    this.alive = true;\n    this.additionalScore = 0;\n    this.curPlat = null;\n    this.nextPlat = null;\n    this.jumping = false;\n    // this.jumpingYVel = 8;\n  }\n\n  getStartPlatforms(){\n    let mid = Math.round(this.environment.platforms.length / 2);\n    return { left: this.environment.platforms[mid - 1], right: this.environment.platforms[mid + 1]};\n  }\n\n  animate(context){\n    this.action();\n    this.draw(context);\n    Object.values(this.projectiles).forEach((p) => {\n      p.animate(context);\n    });\n    this.filterProjectiles();\n  }\n\n  action(){\n    this.move();\n    // this.fetchHumanPosition();\n    if(this.alive){\n      this.collidedWithProjectiles();\n    }\n  }\n\n  draw(context){\n    context.fillStyle = 'purple';\n    context.fillRect(this.xPos, this.yPos, this.width, this.height);\n  }\n\n  move(){\n    this.getCurrentPlatform();\n    if(!this.alive){\n\n      this.yVel += this.CONSTANTS.GRAVITY;\n      this.yPos += this.yVel;\n      return;\n      // this.xPos += this.xVel;\n    }\n\n    if((this.human.xPos >= 800 && this.human.xVel > 0) || (this.human.xPos <= 300 && this.human.xVel < 0)){\n      this.xPos -= this.human.xVel;\n    }\n\n    this.switchDirections();\n    if(this.curPlat && !this.jumping){\n\n      this.yPos = this.curPlat.yStart - this.height;\n      this.xPos += this.xVel;\n    }\n    if(this.isOnEdge()){\n\n      this.beginJump();\n\n      this.jumping = true;\n      this.xPos += this.xVel;\n      this.yPos += this.yVel;\n      this.yVel += this.CONSTANTS.GRAVITY;\n    }\n    // if you have jumped already\n    if(this.jumping){\n\n      // if you have jumped, your yVel is downward, and your ypos is on floor, then land\n      if (this.curPlat && this.yPos >= this.curPlat.yStart - this.height && this.yVel > 0){\n  \n        this.jumping = false;\n        this.yPos = this.curPlat.yStart - this.height;\n        this.yVel = 0;\n        this.xPos += this.xVel;\n      // if you are still midjump\n      }else{\n  \n        this.xPos += this.xVel;\n        this.yPos += this.yVel;\n        this.yVel += this.CONSTANTS.GRAVITY;\n      }\n    }\n  }\n\n  switchDirections(){\n    if (this.goingRight && this.human.xPos < this.xPos - 500) {\n      this.goingLeft = true;\n      this.goingRight = false;\n      this.xVel = -4;\n    } else if (this.goingLeft && this.human.xPos > this.xPos + 500){\n      this.goingRight = true;\n      this.goingLeft = false;\n      this.xVel = 4;\n    }\n  }\n\n  isOnEdge(){\n    if(this.goingLeft){\n      if(this.curPlat\n        && this.yPos === this.curPlat.yStart - this.height\n        && this.xPos <= this.curPlat.xStart + 20){\n          return true;\n      }\n    }else if(this.goingRight){\n      if(this.curPlat\n        && this.yPos === this.curPlat.yStart - this.height\n        && this.xPos >= this.curPlat.xStart + this.curPlat.width - this.width - 10){\n          return true;\n      }\n    }\n    return false;\n  }\n\n  beginJumpOld(){\n    // set local vars for curPlat and nextPlat\n    let curPlat = this.curPlat;\n    let curPlatIdx = this.environment.platforms.indexOf(curPlat);\n    let nextPlat = this.nextPlat;\n    // heightDiff is height to be jumped\n    // maxJumpHeight is lower plat + max height of jump, in context of canvas dimensions\n    let heightDiff = Math.abs(curPlat.yStart - nextPlat.yStart) * 1.3;\n    // set min jump height\n    if(heightDiff < 25) heightDiff = 25;\n    // set max jump height on canvas dimensions according to which plat is lower\n    let maxJumpHeight = (curPlat.yStart < nextPlat.yStart)\n      ? curPlat.yStart + heightDiff : nextPlat.yStart + heightDiff;\n      // gap btw platforms\n    let xGap = this.goingRight\n      // ? nextPlat.xStart - (curPlat.xStart + curPlat.width)\n      ? nextPlat.xStart - this.xPos\n      : this.xPos - (nextPlat.xStart + nextPlat.width);\n    // time jump will take from takeoff to land, in seconds\n    let jumpTime = (xGap / this.xVel);\n    // let jumpTime = (xGap < heightDiff) ? (heightDiff / this.jumpingYVel) : (xGap / this.xVel);\n\n\n    // in numSteps number of moves, yVel must go from x to 0\n    let halfway = xGap / 2;\n    let numSteps = halfway / this.xVel;\n\n    // fallingDist is the distance that the comp will fall after yvel is 0\n    // the minimum vertical distance is has to travel btw maxima and plat\n\n\n\n    let initYVel = (0 + (0.5) * numSteps) * (-1);\n    this.yVel = initYVel;\n    // starting y velocity will need to be such that when the computer reaches the maximum of the jump parabola,\n    // its y velocity will have decreased to zero due to gravity\n  }\n\n  beginJump(){\n    let startX = this.xPos;\n    let startY = this.curPlat.yStart;\n    let endY = this.nextPlat.yStart;\n\n    let endX;\n    if(this.goingRight){\n      endX = this.nextPlat.xStart + 10;\n    }else if(this.goingLeft){\n      endX = this.nextPlat.xStart + this.nextPlat.width - this.width - 10;\n    }\n    let xDiff = Math.abs(endX - startX);\n    \n    // steps steps first half, steps steps second half\n    // let dist, steps, yvel = this.calculateFall(xDiff / 2);\n    let obj = this.calculateFall(xDiff / 2);\n    let dist = obj.dist;\n    let steps = obj.steps;\n    let yVel = obj.yVel;\n\n    // let yVertex = this.nextPlat. + dist;\n    if(this.curPlat.yStart <= this.nextPlat.yStart){\n\n      this.yVel = yVel * (-1);\n    } else if (this.curPlat.yStart > this.nextPlat.yStart){\n\n      let maxHeight = (this.nextPlat.yStart - this.curPlat.yStart - dist) * (-1);\n      this.yVel = this.calculateRise(steps, maxHeight) * (-1);\n\n    }\n\n  }\n\n  calculateRise(steps, maxHeight){\n    let roundedSteps = Math.round(steps);\n    let count = 0;\n    for(let i = 1; i <= roundedSteps; i++){\n      count += i;\n    }\n    let initYvel = (maxHeight + (count * 0.5)) / roundedSteps;\n    return initYvel;\n  }\n\n  calculateFall(xDiff){\n    let steps = Math.abs(Math.round(xDiff / this.xVel));\n    let yVel = 0;\n    let dist = 0;\n    for(let i = 0; i < steps; i++){\n      dist += yVel;\n      yVel += this.CONSTANTS.GRAVITY;\n    }\n    return {dist, steps, yVel};\n  }\n\n  // edited getCurrentPlatform so that it sets this.curPlat to null if the comp is not above a platform,\n  // before it would only set new platforms, not set null for no platforms\n  // p.s. never use forEach, it sucks\n  getCurrentPlatform(){\n    // this.environment.platforms.forEach((platform) => {\n    //   if(this.xPos > platform.xStart && this.xPos < platform.xStart + platform.width){\n    //     this.curPlat = platform;\n    //   }\n    // });\n    for(let i = 0; i < this.environment.platforms.length; i++){\n      let platform = this.environment.platforms[i];\n      if(this.xPos > platform.xStart && (this.xPos < platform.xStart + platform.width)){\n        this.curPlat = platform;\n        if(this.goingLeft){\n          this.nextPlat = this.environment.platforms[i - 1];\n        }else if(this.goingRight){\n          this.nextPlat = this.environment.platforms[i + 1];\n        }\n        return;\n      }\n    }\n    this.curPlat = null;\n    this.nextPlat = null;\n  }\n\n  filterProjectiles(){\n    Object.values(this.projectiles).forEach((p) => {\n      if (!(p => p.xPos < 1110 && p.xPos > -10 && p.yPos > -10 && p.yPos < 710)) {\n        delete this.projectiles[p.id];\n      }\n    });\n  }\n\n  collidedWithProjectiles(){\n    Object.values(this.human.projectiles).forEach((hp) => {\n      if (this.collide(this, hp)) {\n        hp.didHit = true;\n        this.alive = false;\n        this.additionalScore += 1;\n        return true;\n      }\n    });\n  }\n\n  collide(obj1, obj2) {\n    // let obj1TopLeft = {x : obj1.xPos, y: obj1.yPos};\n    // let obj1TopRight = { x: obj1.xPos + obj1.width, y: obj1.yPos };\n    // let obj1BotLeft = { x: obj1.xPos, y: obj1.yPos + obj1.height };\n    // let obj1BotRight = { x : obj1.xPos + obj1.width, y : obj1.yPos + obj1.height};\n\n    let obj1Diag = Math.sqrt(Math.pow(obj1.width / 2, 2) + Math.pow(obj1.height / 2, 2)) / 2;\n\n    // let obj2TopLeft = {x : obj2.xPos, y : obj2.yPos};\n    // let obj2TopRight = { x: obj2.xPos + obj2.width, y: obj2.yPos };\n    // let obj2BotLeft = { x: obj2.xPos, y: obj2.yPos + obj2.height };\n    // let obj2BotRight = {x : obj2.xPos + obj2.width, y : obj2.yPos + obj2.height};\n\n    let obj2Diag = Math.sqrt(Math.pow(obj2.width / 2, 2) + Math.pow(obj2.height / 2, 2)) / 2;\n\n    let totalDelta = Math.sqrt(Math.pow(obj1.xPos - obj2.xPos, 2) + Math.pow(obj1.yPos - obj2.yPos, 2));\n\n    // if((obj1TopLeft.x < obj2BotRight.x && obj1TopLeft.y < obj2BotRight.y) &&\n    //   (obj1Diag + obj2Diag > totalDelta)){\n    //   return true;\n    // } else if (obj1TopRight.x > obj2BotLeft.x && obj1TopRight.y > obj2BotLeft.y && (obj1Diag + obj2Diag > totalDelta)){\n    //   return true;\n    // } else if (obj1BotRight.x > obj2TopLeft.x && obj1BotRight.y > obj2TopLeft.y && (obj1Diag + obj2Diag > totalDelta)){\n    //   return true;\n    // } else if (obj1BotLeft.x < obj2TopRight.x && obj1BotLeft.y > obj2TopRight.y && (obj1Diag + obj2Diag > totalDelta)){\n    //   return true;\n    // }else{\n    //   return false;\n    // }\n\n\n    if (obj1Diag + obj2Diag + 10 > totalDelta) {\n      return true;\n    } else {\n      return false;\n    }\n\n  }\n}","export const collide = (obj1, obj2) => {\n  // let obj1TopLeft = {x : obj1.xPos, y: obj1.yPos};\n  // let obj1TopRight = { x: obj1.xPos + obj1.width, y: obj1.yPos };\n  // let obj1BotLeft = { x: obj1.xPos, y: obj1.yPos + obj1.height };\n  // let obj1BotRight = { x : obj1.xPos + obj1.width, y : obj1.yPos + obj1.height};\n\n  let obj1Diag = Math.sqrt(Math.pow(obj1.width / 2, 2) + Math.pow(obj1.height / 2, 2)) / 2;\n\n  // let obj2TopLeft = {x : obj2.xPos, y : obj2.yPos};\n  // let obj2TopRight = { x: obj2.xPos + obj2.width, y: obj2.yPos };\n  // let obj2BotLeft = { x: obj2.xPos, y: obj2.yPos + obj2.height };\n  // let obj2BotRight = {x : obj2.xPos + obj2.width, y : obj2.yPos + obj2.height};\n\n  let obj2Diag = Math.sqrt(Math.pow(obj2.width / 2, 2) + Math.pow(obj2.height / 2, 2)) / 2;\n\n  let totalDelta = Math.sqrt(Math.pow(obj1.xPos - obj2.xPos, 2) + Math.pow(obj1.yPos - obj2.yPos, 2));\n  \n  // if((obj1TopLeft.x < obj2BotRight.x && obj1TopLeft.y < obj2BotRight.y) &&\n  //   (obj1Diag + obj2Diag > totalDelta)){\n  //   return true;\n  // } else if (obj1TopRight.x > obj2BotLeft.x && obj1TopRight.y > obj2BotLeft.y && (obj1Diag + obj2Diag > totalDelta)){\n  //   return true;\n  // } else if (obj1BotRight.x > obj2TopLeft.x && obj1BotRight.y > obj2TopLeft.y && (obj1Diag + obj2Diag > totalDelta)){\n  //   return true;\n  // } else if (obj1BotLeft.x < obj2TopRight.x && obj1BotLeft.y > obj2TopRight.y && (obj1Diag + obj2Diag > totalDelta)){\n  //   return true;\n  // }else{\n  //   return false;\n  // }\n  \n  \n  if(obj1Diag + obj2Diag + 10 > totalDelta){\n    return true;\n  }else{\n    return false;\n  }\n\n}\n\nexport const objectCollision = (obj, projectiles) => {\n  projectiles.forEach((p) => {\n    if(collide(obj, p)){\n      p.didHit = true;\n      debugger;\n      obj.alive = false;\n    }\n  })\n}","import \"./styles/index.scss\";\n\nimport Game from './game';\n\nconst canvas = document.getElementById('main-canvas');\nconst game = new Game(canvas);\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  game.restart();\n});\n\n","import Environment from \"./environment\";\nimport Human from './human';\nimport Background from \"./background\";\nimport Computer from \"./computer\";\nimport Score from \"./score\";\nimport LandComputer from \"./land_computer\";\nimport * as CollisionUtil from './util/collision_logic';\n\n\nexport default class Game{\n  constructor(canvas){\n    this.context = canvas.getContext('2d');\n    this.dimensions = {\n      height: canvas.height,\n      width: canvas.width\n    };\n    this.running = false;\n\n    this.computers = [];\n    this.landComputers = [];\n    this.computersBeingAdded = 0;\n    this.numComputers = this.computers.length + this.computersBeingAdded;\n\n    this.humanProjectiles = {};\n    this.computerProjectiles = {};\n\n    this.projectileOffset = 100;\n\n    this.startMenu = document.getElementById('start-menu');\n    this.playButton = document.getElementById('play-button');\n    this.playButton.addEventListener('mousedown', () => {\n      document.getElementById('start-menu').remove();\n      this.click();\n    });\n\n  }\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n  filterProjectiles(){\n    this.grabHumanProjectiles();\n    this.grabComputerProjectiles();\n    this.checkCollisions();\n    this.deleteProjectiles(this.humanProjectiles);\n    this.deleteProjectiles(this.computerProjectiles);\n  }\n\n  deleteProjectiles(projectiles){\n    Object.values(projectiles).forEach((p) => {\n      if(p.didHit){\n        delete projectiles[p.id];\n      }else if(!p.alive){\n        delete projectiles[p.id];\n      }else if(this.offScreen(p) && !p.homing){\n        delete projectiles[p.id];\n      }\n    })\n  }\n\n  offScreen(projectile){\n    if(projectile.xPos > 1150 || projectile.xPos < -50){\n      return true;\n    }else if(projectile.yPos > 800 || projectile.yPos < -50){\n      return true;\n    }\n    return false;\n  }\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n  grabHumanProjectiles(){\n    this.humanProjectiles = this.human.projectiles;\n  }\n\n  grabComputerProjectiles(){\n    let res = {};\n    this.computers.forEach((computer) => {\n      res = Object.assign(res, computer.projectiles);\n    })\n    this.computerProjectiles = res;\n  }\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n  checkCollisions(){\n    CollisionUtil.objectCollision(this.human, Object.values(this.computerProjectiles));\n\n    let homingProjectiles = Object.values(this.computerProjectiles).filter(p => p.homing === true);\n    homingProjectiles.forEach((hp) => {\n      CollisionUtil.objectCollision(hp, Object.values(this.humanProjectiles));\n    })\n\n    this.computers.forEach((computer) => {\n      CollisionUtil.objectCollision(computer, Object.values(this.humanProjectiles));\n    })\n  }\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n  // if computer players are offscreen, that means theyre no longer alive, and dont need to be\n  // in the game's computers list, and they dont need to be rendered\n  filterComputers(){\n    this.computers = this.computers.filter(c => c.yPos < 1000);\n  }\n\n  // addEnemyScore(){\n  //   let that = this;\n  //   this.computers.forEach((comp) => {\n  //     that.score.score += comp.additionalScore;\n  //     comp.additionalScore = 0;\n  //   });\n  // }\n\n  switchRounds(){\n    if(this.score.score > 5){\n      this.background.round = 1;\n    }\n  }\n\n  \n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n\n\n  setNumComputers(){\n    this.numComputers = this.computers.length + this.computersBeingAdded;\n  }\n\n  spawnComputer(){\n    this.computersBeingAdded += 1;\n    let newCompStartX;\n    let randNum = Math.random();\n    if(randNum <= 0.5){\n      newCompStartX = 1150;\n    }else{\n      newCompStartX = -50;\n    }\n    window.setTimeout(() => {\n      this.computers.push(\n        new Computer(this.environment, this.context, this.human, newCompStartX)\n      );\n      this.computersBeingAdded -= 1;\n    }, 5000);\n  }\n\n  setPlayerTracking(){\n    this.computers.forEach((comp) => {\n      Object.values(comp.projectiles).forEach((proj) => {\n        proj.playerXVel = this.human.xVel;\n        proj.playerXPos = this.human.xPos;\n        proj.playerYPos = this.human.yPos;\n      });\n    });\n  }\n\n  // sendEnemyProjectiles(){\n  //   this.computers.forEach((comp) => {\n  //     Object.values(comp.projectiles).forEach((projectile) => {\n  //       this.human.computerProjectiles[projectile.id] = projectile;\n  //     });\n  //   });\n  // }\n\n  configureProjectile(pos, homing=false, projectile=null){\n    let randNum = Math.random();\n    \n    let xDelta;\n    let yDelta;\n\n    // if projectile is homing, we need to call this method and compare the projectile's\n    // current position with that of the human player, else we are comparing the player and the computer\n    if(homing === false){\n      xDelta = pos.x - this.xPos;\n      yDelta = pos.y - this.yPos;\n    }else if(homing === true){\n      xDelta = pos.x - projectile.xPos;\n      yDelta = pos.y - projectile.yPos;\n    }\n\n    if(homing === false){\n      let randOffset = Math.round(Math.random() * 200);\n      if(randNum < 0.25){\n        xDelta += randOffset;\n      }else if(randNum > 0.25 && randNum < 0.5){\n        xDelta -= randOffset;\n      }\n    }\n\n    let squaredDeltaX = Math.pow(xDelta, 2);\n    let squaredDeltaY = Math.pow(yDelta, 2);\n    let totalDeltasquared = squaredDeltaX + squaredDeltaY;\n    let totalDelta = Math.sqrt(totalDeltasquared);\n\n    let proportion;\n    if(projectile === null){\n      proportion = 5 / totalDelta;\n    }else{\n      proportion = 3 / totalDelta;\n    }\n    let xVel = xDelta * proportion;\n    let yVel = yDelta * proportion;\n\n    return [xVel, yVel];\n  }\n\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n// --------------------------------------------------------------------------\n\n  restart(){\n    this.background = new Background(this.dimensions);\n    this.environment = new Environment(this.dimensions, this.context);\n    this.human = new Human(this.environment, this.context, this.computerProjectiles);\n    this.environment.human = this.human;\n    this.score = new Score(this.context);\n    this.computers = [];\n    let i = 1;\n    let compStartX;\n    while(i < 1){\n      if(i % 2 === 0){\n        compStartX = 1150 + (100 * i);\n      }else{\n        compStartX = -50 - (100 * i);\n      }\n      this.computers.push(new Computer(this.environment, this.context, this.human, this.projectileOffset, compStartX));\n      this.projectileOffset += 100;\n      i += 1;\n    }\n    // let j = 0;\n    // while(j < 10){\n    //   this.landComputers.push(new LandComputer(this.environment, this.context, this.human, j * 5));\n    //   j += 1;\n    // }\n    this.landComp = new LandComputer(this.environment, this.context, this.human);\n    this.running = false;\n\n    // this.step();\n\n    this.run();\n  }\n\n  // this will be run upon restart\n  run(){\n  }\n\n  click(){\n    if(!this.running){\n      this.play();\n    }\n  }\n\n  play(){\n    this.running = true;\n    this.step();\n  }\n\n  step(){\n    if(this.gameOver()){\n      this.rerun();\n    }\n    this.animate();\n    this.filterProjectiles();\n    // this.addEnemyScore();\n\n\n    this.switchRounds();\n    this.filterComputers();\n    if(this.running){\n      window.requestAnimationFrame(this.step.bind(this));\n    }\n  }\n\n  animate(){\n    // this.sendEnemyProjectiles();\n    this.background.animate(this.context);\n    this.environment.animate(this.context);\n    this.human.animate(this.context);\n    this.score.animate();\n    this.animateProjectiles();\n\n    this.setPlayerTracking();\n\n    this.computers.forEach((c) => {\n      c.animate(this.context, this.human);\n    });\n    this.landComp.animate(this.context);\n    // this.landComputers.forEach((comp) => {\n    //   comp.animate(this.context);\n    // })\n\n    this.setNumComputers();\n\n    if(this.numComputers < 1){\n      this.spawnComputer();\n    }\n\n  }\n\n  animateProjectiles(){\n    Object.values(this.humanProjectiles).forEach((p) => {\n      p.animate(this.context);\n    })\n    Object.values(this.computerProjectiles).forEach((p) => {\n      if(p.homing){\n        let pos = {x : this.human.xPos, y: this.human.yPos};\n        p.animate(this.context, ...this.configureProjectile(pos, true, p));\n      }else{\n        p.animate(this.context);\n      }\n    })\n  }\n\n  gameOver(){\n    if(this.human.yPos > 710){\n      return true;\n    }else if(!this.human.alive && this.human.yPos > 710){\n      return true;\n    }else{\n      return false;\n    }\n  }\n\n  rerun(){\n    let gameAndTitle = document.getElementById('game-and-title');\n    gameAndTitle.appendChild(this.startMenu);\n    this.restart();\n  }\n\n\n  // --------------------------------------------------------------------------\n  // --------------------------------------------------------------------------\n  // --------------------------------------------------------------------------\n  // --------------------------------------------------------------------------\n  // --------------------------------------------------------------------------\n  // --------------------------------------------------------------------------\n\n  // addProjectiles(){\n  //   this.allProjectiles = this.human.projectiles;\n  //   for(let i = 0; i < this.computers.length; i++){\n  //     let curComp = this.computers[i];\n  //     this.allProjectiles = Object.assign(this.allProjectiles, curComp.projectiles);\n  //   }\n  // }\n\n\n\n\n\n}\n\n\n\n"],"sourceRoot":""}